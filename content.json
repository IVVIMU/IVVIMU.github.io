{"meta":{"title":"IVVIMU","subtitle":"","description":"","author":"Linmu","url":"https://IVVIMU.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-04-16T05:36:15.000Z","updated":"2020-04-16T07:11:25.275Z","comments":true,"path":"categories/index.html","permalink":"https://ivvimu.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-04-16T04:09:21.000Z","updated":"2020-04-16T07:11:38.981Z","comments":true,"path":"tags/index.html","permalink":"https://ivvimu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript学习记录（三) 节点","slug":"JavaScript学习记录（三) 节点","date":"2020-05-04T13:30:32.000Z","updated":"2020-05-04T13:44:28.997Z","comments":true,"path":"2020/05/04/JavaScript学习记录（三) 节点/","link":"","permalink":"https://ivvimu.github.io/2020/05/04/JavaScript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%89)%20%E8%8A%82%E7%82%B9/","excerpt":"DOM节点 万物皆节点 DOM是由节点组成的。 网页中的所有内容都是节点（标签，属性，文本，注释等），节点用node来表示。 节点至少拥有三个基本属性nodeType（节点类型）、nodeName（节点名称）、nodeValue（节点值）","text":"DOM节点 万物皆节点 DOM是由节点组成的。 网页中的所有内容都是节点（标签，属性，文本，注释等），节点用node来表示。 节点至少拥有三个基本属性nodeType（节点类型）、nodeName（节点名称）、nodeValue（节点值） 元素节点 nodeType为1 属性节点 nodeType为2 文本节点 nodeType为3（包括文字、空格、换行等 ） 注释节点 nodeType为8 文档节点 nodeType为9（整个HTML文档就是一个文档节点，所有节点都是Object.） 节点的获取123456//1.通过id获取单个标签var ele1 = document.getElementById(\"IdName\");//2.通过标签名获取标签数组(s)var ele2 = document.getElementsByTagName(\"TagName\");//3.通过类名获得标签数组(s)var ele3 = document.getElementsByClassName(\"ClassName\") 因为通过2,3方式获取的是标签数组,所以习惯遍历数组 即便数组中的值只有一个,也需遵守如下获取方式: 12document.getElementsByTagName(\"TagName\")[0]; //取数组中第一个元素document.getElementsClassName(\"ClassName\")[0]; //去数组中第一个元素 节点层级 DOM树把节点划分成不同的层级关系,常见的是父子兄层级关系 节点的访问关系,是以属性的方式存在的 父节点 node.parentNode 12345678910111213141516171819202122232425262728&lt;body&gt; &lt;!--实例模板，在子节点代码实例中省略--&gt; &lt;div&gt;我是div&lt;/div&gt; &lt;span&gt;我是span&lt;/span&gt; &lt;ul&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;我是li1&lt;/li&gt; &lt;li&gt;我是li2&lt;/li&gt; &lt;li&gt;我是li3&lt;/li&gt; &lt;li&gt;我是li4&lt;/li&gt; &lt;/ol&gt; &lt;div class=\"demo\"&gt; &lt;div class=\"box\"&gt; &lt;span class=\"SpanName\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var SpanName = document.querySelector('.SpanName'); console.log(SpanName.parentNode); &lt;/script&gt;&lt;/body&gt; &gt; 输出所选元素最近的父级节点 &gt; &gt; &gt; *&lt;div class=&quot;box&quot;&gt;...&lt;/div&gt;* 子节点 1、parentNode.childNodes(标准) 123456789......&lt;script&gt; var ul = document.querySelector(\"ul\"); //DOM提供的方法（API）获取 var lis = ul.querySelectorAll(\"li\"); //parentNode.childNodes方法获取 console.log(ul.childNodes);&lt;/script&gt;...... 输出所有的子节点，包含元素节点，文本节点(文字，空格，换行)等 NodeList(9)——里面包含5个文本节点（换行）与5个元素节点 2、parentNode.children(非标准) parentNode.children是一个只读属性，返回所有的子元素节点，不返回其余节点 1234567......&lt;script&gt; var ul = document.querySelector(\"ul\"); //parentNode.children方法获取 console.log(ul.children);&lt;/script&gt;...... 输出所选元素节点 HTMLCollection(4) 如何获取特定元素？ 123456789101112131415161718192021......&lt;script&gt; var ol = document.querySelector(\"ol\"); //firstChild获取第一个子节点，包括文本节点,找不到则返回null console.log(ol.firstChild); //lastChild获取最后一个子节点，包括文本节点,找不到则返回null console.log(ol.lastChild); //以下两个方法有兼容性问题，IE9以上才支持 //firstElementChild返回第一个子元素节点 console.log(ol.firstElementChild); //lastElementChild返回最后一个子元素节点 console.log(ol.lastElementChild); //实际开发写法 //返回第一个子元素节点 console.log(ol.children[0]); //返回最后一个子元素节点 console.log(ol.children[ol.children.length - 1]); &lt;/script&gt;...... 输出 #text #text *我是li1* *我是li4* *我是li1* *我是li4* 兄节点 node.nextSibling node.previousSibling 12345678910111213&lt;body&gt; &lt;div&gt;我是div&lt;/div&gt; &lt;span&gt;我是span&lt;/span&gt; &lt;script&gt; var div = document.querySelector(\"div\"); var span = document.querySelector(\"span\") //返回下一个兄弟节点，包括文本节点（换行），找不到则返回null console.log(div.nextSibling); //返回上一个兄弟节点，包括文本节点（换行），找不到则返回null console.log(span.previousSibling); &lt;/script&gt;&lt;/body&gt; node.nextElementSibling node.previousElementSibling 12345678910111213&lt;body&gt; &lt;div&gt;我是div&lt;/div&gt; &lt;span&gt;我是span&lt;/span&gt; &lt;script&gt; var div = document.querySelector(\"div\"); var span = document.querySelector(\"span\") //返回下一个兄弟元素节点，找不到则返回null console.log(div.nextElementSibling); //返回上一个兄弟元素节点，找不到则返回null console.log(span.previousElementSibling); &lt;/script&gt;&lt;/body 注意：有兼容性问题，IE9以上才支持 如何解决兼容性问题？——封装一个兼容性函数 12345678910function getNextElementSibling(element) &#123; var el = element; while (el = el.nextSibling) &#123; if (el.nodeType ===1) &#123; //返回元素节点 return el; &#125; &#125; return null;&#125; 创建节点 1、创建节点 document.createElement(“TagName”) 根据需求动态生成，称为动态创建元素节点 2、添加节点 node.appendChild(child) 将一个节点添加到指定父节点的子节点列表末尾 node.insertBefore(child,指定元素位置) 将一个节点添加到父节点的指定子节点前面 12345678910111213141516&lt;body&gt; &lt;ul&gt;&lt;/ul&gt; &lt;script&gt; var ul = document.querySelector(\"ul\"); //创建元素节点 var li = document.createElement(\"li\"); //添加节点 ul.appendChild(li); //指定位置添加节点 var lis = document.createElement(\"li\"); ul.insertBefore(lis,ul.children[0]); &lt;/script&gt;&lt;/body&gt; 删除节点 node.removeChild(child) node.removeChild()方法从DOM中删除一个子节点，返回删除的节点 克隆节点 node.cloneNode() 返回调用该方法的节点的一个副本 node.cloneNode(); 括号里为空或者为false——浅拷贝，只复制标签，不复制内容 node.cloneNode(true); 括号里为true——深拷贝，既复制标签也复制内容 节点属性 获取节点的属性 方法1 元素节点.属性 元素节点[属性] 1234567891011121314151617181920&lt;body&gt; //实例模板，下同 &lt;img src=\"#1\" class=\"image1-box\" title=\"cover1\" alt=\"封面\"&gt; &lt;script&gt; //获取节点 var imgNode = document.getElementsByTagName(\"img\")[0]; console.log(imgNode.src); console.log(imgNode.className); //注意：className console.log(imgNode.title); console.log(\"--------------------\"); console.log(imgNode[\"src\"]); console.log(imgNode[\"className\"]);//注意：className console.log(imgNode[\"title\"]); &lt;/script&gt;&lt;/body&gt; 方法2 node.getAttribute(AttributeName) 123456789......&lt;script&gt; console.log(imgNode.getAttribute(\"src\")); console.log(imgNode.getAttribute(\"class\"));//注意是class console.log(imgNode.getAttribute(\"title\"));&lt;/script&gt;...... 与方法一的区别在于：方法1是直接操作标签，而方法2是把标签作为DOM节点 设置节点的属性 方法1 node.AttributeName = “AttributeValue” 方法2 node.setAttribute(AttributeName,AttributeValue) 123456789101112131415......&lt;script&gt; //方法1 imgNode.src = \"#2\"; imgNode.className = \"image2-box\"; //注意，className imgNode.title = \"cover2\" //方法2 imgNode.setAttribute(\"src\",\"#2\"); imgNode.setAttribute(\"class\",\"image2-box\");//注意，class imgNode.setAttribute(\"title\",\"cover2\");&lt;/script&gt;...... 删除节点的属性 node.removeAttribute(AttributeName) 12345678......&lt;script&gt; imgNode.removeAttribute(\"class\"); imgNode.removeAttribute(\"id\");&lt;/script&gt;......","categories":[{"name":"Records","slug":"Records","permalink":"https://ivvimu.github.io/categories/Records/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ivvimu.github.io/tags/JavaScript/"}]},{"title":"JavaScript学习记录（二) 预解析","slug":"JavaScript学习记录（二) 预解析","date":"2020-04-24T13:45:32.000Z","updated":"2020-05-02T12:41:58.853Z","comments":true,"path":"2020/04/24/JavaScript学习记录（二) 预解析/","link":"","permalink":"https://ivvimu.github.io/2020/04/24/JavaScript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C)%20%E9%A2%84%E8%A7%A3%E6%9E%90/","excerpt":"JavaScript引擎运行JS代码分为两步：预解析——代码执行 预解析——把JS代码里所有的变量和函数提升到当前作用域的最前面 预解析分为变量预解析（变量提升）和函数预解析（函数提升） 变量提升就是把所有的变量声明提升到当前作用域最前面，不提升赋值操作 函数提升就是把所有函数声明提升到当前作用域的最前面，不调用函数 代码执行——按照代码书写的顺序从上往下执行","text":"JavaScript引擎运行JS代码分为两步：预解析——代码执行 预解析——把JS代码里所有的变量和函数提升到当前作用域的最前面 预解析分为变量预解析（变量提升）和函数预解析（函数提升） 变量提升就是把所有的变量声明提升到当前作用域最前面，不提升赋值操作 函数提升就是把所有函数声明提升到当前作用域的最前面，不调用函数 代码执行——按照代码书写的顺序从上往下执行 实例 作用域实例 12345678var num = 10;function fn() &#123; console.log(num); var num = 20; console.log(num);&#125;fn(); 以上实例相当于执行以下代码 123456789var num;function fn() &#123; var num; console.log(num); num = 20 console.log(num);&#125;num = 10;fn(); Console输出： undenfined 20 赋值操作实例 12345fun();// 函数表达式var fun = funciton() &#123; console.log(22)&#125; Console报错——Uncaught TypeError: fun is not a function …. 以上实例相当于执行以下代码 123456var fun; fun();fun = function() &#123; console.log(22);&#125;// 函数表达式，调用必须写在函数表达式的下面 经典实例 1234567891011fn();console.log(c);console.log(b);console.log(a);function f1() &#123; var a = b = c = 9; console.log(a); console.log(b); console.log(c);&#125; var a = b = c = 9 相当于 var a = 9; b = 9; c = 9; b 和 c 直接赋值，没有var声明，为全局变量 注意区别集体声明——var a = 9, b = 9, c = 9; 故上述实例相当于执行以下代码 123456789101112function f1() &#123; var a; a = b = c = 9; console.log(a); console.log(b); console.log(c);&#125;fn();console.log(c);console.log(b);console.log(a); Console输出 9 9 9 9 9 Uncaught ReferenceError: a is not defined 2020.04.25 修改代码块","categories":[{"name":"Records","slug":"Records","permalink":"https://ivvimu.github.io/categories/Records/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ivvimu.github.io/tags/JavaScript/"}]},{"title":"JavaScript学习记录（一)  运算符","slug":"JavaScript学习记录（一)  运算符","date":"2020-04-19T11:10:04.000Z","updated":"2020-05-02T12:42:05.697Z","comments":true,"path":"2020/04/19/JavaScript学习记录（一)  运算符/","link":"","permalink":"https://ivvimu.github.io/2020/04/19/JavaScript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80)%20%20%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"递增与递减运算符前置递增和后置递增小结 前置：先变量自加1，后表达式返回值； 后置：先表达式原值返回，后变量自加1；","text":"递增与递减运算符前置递增和后置递增小结 前置：先变量自加1，后表达式返回值； 后置：先表达式原值返回，后变量自加1； 单独使用时，运行结果相同； 与其他代码联用时，执行结果会不同； 大多使用后置递增/减，且代码独占一行； 递增实例123456789101112131415var a = 10;++a; //++a==11 a==11var b = ++a + 2; //a==12 ++a==12console.log(b); //14var c = 10;c++; //c++==11 C==11var d = c++ + 2; //c++==11 c==12console.log(d); //13var e = 10;var f = e++ + ++e; //e++==10 e==11 |--| e==12 ++e==12console.log(f); //22//后置自增，先表达式返回原值，后变量再自加1 递减同理 比较运算符 符号 作用 用法 = 赋值 符号右边赋值给符号左边 == (!=) 判断 判断两边值是否相等（有隐式转换） ===(!==) 判断 判断两边的值和数据类型是否完全相同(不同类型不比较，切且无结果，同类型才比较) 12console.log(18 == \"18\"); //trueconsole.log(18 === \"18\"); //true 注意 1console.log(NaN != NaN); //true NaN是除数字的任意值，但绝不是确切的某一个值； NaN是一个范围,而不能代表一个确定的值。 逻辑运算符短路运算（逻辑中断） 短路运算原理：当有多个表达式（值）时，左边的表达式值可以确定结果时，就不再继续运算右边表达式的值 逻辑与 语法：表达式1 &amp;&amp; 表达式2 如果第一个表达式的值为真，则返回表达式2 如果第一个表达式的值为假，则返回表达式1 1234console.log(123 &amp;&amp; 456); //456console.log(0 &amp;&amp; 456); //0console.log(0 &amp;&amp; 1 + 2 &amp;&amp; 456 * 567); //0console.log('' &amp;&amp; 1 + 2 &amp;&amp; 456 * 567); //'' 逻辑或 语法：表达式1 || 表达式2 如果第一个表达式为真，则返回表达式1 如果第一个表达式为假，则返回表达式2 1234567console.log(123 || 456); //123console.log(123 || 456 || 456 + 123); //123console.log(0 || 456 ||456 + 123); //456var num = 0;console.log(123 || num++); //123console.log(num); //0 2020.04.19 创建 2020.04.20 短路运算（逻辑中断）增补 2020.04.25 修改代码块","categories":[{"name":"Records","slug":"Records","permalink":"https://ivvimu.github.io/categories/Records/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ivvimu.github.io/tags/JavaScript/"}]},{"title":"博客日志","slug":"博客日志","date":"2020-04-15T14:14:33.000Z","updated":"2020-05-01T11:53:37.315Z","comments":true,"path":"2020/04/15/博客日志/","link":"","permalink":"https://ivvimu.github.io/2020/04/15/%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97/","excerpt":"这是博客日志详情点击阅读更多","text":"这是博客日志详情点击阅读更多这里没有任何有价值的文字存在，但表情包或许存在。 所有博客功能最开始都会在该博客测试，如果你机缘巧合看到， 对于浪费了你生命的10秒钟时间，我真的感到非常私密马赛。 欢迎在Gitalk板块留言，发个表情包也可以啊。 2020.04.17,21:37 MU 2020.04.29 21:25 更改侧边栏样式。 发现Ayer原作者没有为侧边栏写Javascript代码，采用了更改CSS样式达成目的，造成移动端不兼容，待修正及添加Javascript。2020.05.01 Github安全警示，更新jQuery，出现Bug","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-04-15T09:08:24.090Z","updated":"2020-04-21T10:52:47.411Z","comments":true,"path":"2020/04/15/hello-world/","link":"","permalink":"https://ivvimu.github.io/2020/04/15/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Hello HexoQuick StartCreate a new post","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Hello HexoQuick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Records","slug":"Records","permalink":"https://ivvimu.github.io/categories/Records/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ivvimu.github.io/tags/JavaScript/"}]}